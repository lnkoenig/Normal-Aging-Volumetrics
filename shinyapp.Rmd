---
title: "Brain Atrophy in Normal Aging"
author: "Lauren Koenig"
output: 
  html_notebook
runtime: shiny
---
### Description:
Below are the data from publications describing atrophy that occurs in normal aging. The cohort displayed comes from ADNI and DIAN controls. All participants are cognitively normal, amyloid PET negative, and remained cognitively normal for at least 3 year after the displayed MR scan. The exception are the amyloid+ participants which can be added, who were cognitively normal but amyloid PET positive and were not followed longitudinally.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r Load and Clean Up Data, include=FALSE}
#Load the R packages necessary for rest of script
packages <- c("cowplot", "ggseg", "ggplot2", "ggrepel", "tidyverse", "shiny", "lm.beta", "toOrdinal")
for( i in packages ){
  #  require returns TRUE invisibly if it was able to load package
  if( ! require( i , character.only = TRUE ) ){
    #  If package was not able to be loaded then re-install
    if(i =="ggseg") {
      source("https://neuroconductor.org/neurocLite.R")
      neuro_install('ggseg')
      library('ggseg')
    }else{
        install.packages( i , dependencies = TRUE )
         #  Load package after installing
          require( i , character.only = TRUE )
      }
    }
}

#load data
load("Normal_Aging_Input_Shiny_2021-06-11.RData")

#Set normals data's min and max ages
n_min <- ceiling(min(normals$Age, na.rm = TRUE))
n_max <- floor(max(normals$Age, na.rm = TRUE))

#prevents scientific notation
options(scipen=999)

region_list <- colnames(select(normals, `Bankssts Thickness`:`5th Ventricle Volume`))


#For debugging:
# input <- data.frame(row.names = "input")
# input$span = 0.7
# input$sex = 1
# input$pcad = FALSE
# input$ROI_name = "Hippocampus Volume"
# input$individual_points = FALSE
# input$Age = 60
# input$ICV = 1500000
# input$region_val = 9000


```

```{r make normal aging curve}
ui <- shinyUI(fluidPage(
    sidebarLayout(
    sidebarPanel(
      sliderInput("span", label = "Alpha (smoothing)", min = 0.1, value = 0.7, max = 2, step=0.1 ),
      radioButtons("sex", label = "Subset Data:", choices = list("Everyone" = 1, "Men Only" = 2, "Women Only" = 3)),
      checkboxInput("pcad",label = "Include Amyloid+"),
      selectInput("ROI_name", label = "Aging Curve Options:", choices = region_list, selected = "Hippocampus Volume"),
      checkboxInput("individual_points",label = "Show Individual data points"),
      numericInput("Age", label = ("Age (years)"), value = NA),
      numericInput("region_val", label = ("Patient Total Volume or Average Thickness"), value = NA), 
      numericInput("ICV", label = ("Intracranial volume (not needed for thicknesses)"), value = 1500000),
      width=2),
    mainPanel(tabsetPanel(type = "tabs",
                  tabPanel("Aging Curves", plotOutput("region_plot")),
                  tabPanel("Whole Brain Map", plotOutput("ggseg_plot")),
                  tabPanel("Whole Brain Table", tableOutput("table"))
      )
     ))))

  
server <- shinyServer(function(input, output) {  
  
  #define function to calculation data
  fit_data <- function(normals, region, span_input){
        smoothFit <- loess( as.matrix(normals[,region]) ~ normals$Age, degree=1, span=span_input) #locally fits a polynomial surface
        smoothPred <- predict( smoothFit, newdata=n_min:n_max, se=TRUE ) #uses loess fit to predict data for each age
        stand_dev2 <- matrix()
        for (i in 1:length(n_min:n_max)) {
          stand_dev2[i] <- sd(as.matrix(normals[normals$Age > seq(n_min,n_max, by=1)[i]-1 & normals$Age < seq(n_min,n_max, by=1)[i]+1,][,region]))
        }
        sd_fit <- loess(stand_dev2 ~ c(n_min:n_max), degree=1, span=span_input)
        sd_pred <- predict(sd_fit, newdata=n_min:n_max)
        plotFrame <- data.frame( Age=c(n_min:n_max), fit=smoothPred$fit, sd=sd_pred ) #combines all the model's data into single dataframe

        return(plotFrame)
  }
  
  region_map_data <- function(normals){
    mc <- "holm"

    #make dataframes to hold results
    results <- data.frame() #results from normal aging cohort
    slopes <- data.frame(Age=(n_min+1):n_max)
    
    age_range <- 1 #range at which slopes are calculated (1 = 1 year bin)
      
    for (region in region_list){
      ####linear pattern
      model <- lm.beta(lm(normals[,region] ~ normals$Age ))
      results[region, "Age_p"] <- summary(model)$coefficients[2,5]
      results[region, "Age_beta"] <- summary(model)$coefficients[2,2]
  
      ####non-linear pattern
      plotFrame <- fit_data(normals, region, input$span)

      slope <- diff(plotFrame$fit, differences=1)/age_range #normalize to range fit the data (if using an age increase other than 1 year it switches it to per year)
      slope <- (slope) / plotFrame$fit[-length(plotFrame$fit)] #make it percent change

      #save data to dataframe
      slopes[,region] <- slope

      #make lm for each region and each variable in normals list, save p-value
       model <- lm.beta(lm(slopes[,region] ~ slopes$Age ))
       results[region, "slope_p"] <- summary(model)$coefficients[2,5]
       results[region, "slope_beta"] <- summary(model)$coefficients[2,2]
    }  
    
  #Once done finding all p-values, do multiple comparisons correction
  results[,"Age_p"] <- p.adjust((results[,"Age_p"]), method = mc)
  results[,"slope_p"] <- p.adjust((results[,"slope_p"]), method = mc)

   for (i in c("Age_beta", "slope_beta")){results[i] <- round(results[i], digits = 3)}
    
    for (i in c("Age_p", "slope_p")){
      for (j in 1:length(results[,i])) {
        if (results[j,i] >=0.01) {results[j,i] <- format(round(as.numeric(results[j,i]), digits = 2), nsmall=2)}
        else if (results[j,i]<0.01 & results[j,i]>=0.001 ){results[j,i] <- round(as.numeric(results[j,i]), digits = 3)}
        else if (results[j,i]<0.001){results[j,i] <- "<0.001" }
      }
    }
  results$Region <- rownames(results)
  results <- relocate(results, Region)
  
 

  
        return(results)
  } 
  
  ggseg_graph <- function(results){
     
        
        
        #reverse values for making images
      reverse <- c("Lateral.Ventricle_volume", "choroid.plexus_volume" , "CSF_volume", "Inf.Lat.Vent_volume", "non.WM.hypointensities_volume", "Optic.Chiasm_volume", "Ventricle_Cerebrum_Ratio", "vessel_volume", "WM.hypointensities_volume", "X3rd.Ventricle_volume", "X4th.Ventricle_volume", "X5th.Ventricle_volume"  )
      
      
      #flip linear model beta values where it makes sense
      results_adjusted <- results
      results_adjusted[ row.names(results_adjusted) %in% reverse,]$Age_beta <- -1*results_adjusted[ row.names(results_adjusted) %in% reverse,]$Age_beta
      results_adjusted[ row.names(results_adjusted) %in% reverse,]$slope_beta <- -1*results_adjusted[ row.names(results_adjusted) %in% reverse,]$slope_beta
      
      
      thicknesses <- results_adjusted[1:34,]
      volumes <- results_adjusted[35:68,]
      subcort <- results_adjusted[69:76,]
      
      rownames(thicknesses) <- c("banks superior temporal", "caudal anterior cingulate", "caudal middle frontal", "cuneus", "entorhinal", "frontal pole", "fusiform", "inferior parietal", "inferior temporal", "insula", "isthmus cingulate", "lateral occipital", "lateral orbitofrontal", "lingual", "medial orbito frontal", "middle temporal", "para central", "parahippocampal", "pars opercularis", "pars orbitalis", "pars triangularis", "pericalcarine", "post central", "posterior cingulate", "pre central", "precuneus", "rostral anterior cingulate", "rostral middle frontal", "superior frontal", "superior parietal", "superior temporal", "supramarginal", "temporal pole", "transverse temporal")
      
      rownames(volumes) <- c("banks superior temporal", "caudal anterior cingulate", "caudal middle frontal", "cuneus", "entorhinal", "frontal pole", "fusiform", "inferior parietal", "inferior temporal", "insula", "isthmus cingulate", "lateral occipital", "lateral orbitofrontal", "lingual", "medial orbito frontal", "middle temporal", "para central", "parahippocampal", "pars opercularis", "pars orbitalis", "pars triangularis", "pericalcarine", "post central", "posterior cingulate", "pre central", "precuneus", "rostral anterior cingulate", "rostral middle frontal", "superior frontal", "superior parietal", "superior temporal", "supramarginal", "temporal pole", "transverse temporal")
      
      #change rownames for aseg
      rownames(subcort) <- c("amygdala", "caudate", "hippocampus", "lateral ventricle", "pallidum", "putamen", "thalamus proper", "ventral DC" )
      
      
      
      
      ####### Graph Age model beta values ########
      
      theme <- theme(axis.text.x=element_blank(), 
                     axis.title.x=element_blank(), 
                     legend.text=element_text(size=10),
                     legend.title=element_text(size=12,face="italic"),
                     legend.position="right", 
                     plot.title=element_text(size=10,hjust = 0.5) )
      
      scale1 <- scale_fill_gradient(low="navyblue", high="gold",na.value = "grey", limits=c(-0.75,0.08)) 
      scale2 <- scale_fill_gradient2(low = ("#f46d43"), mid = "white",  high = ("#74add1"), midpoint = 0,na.value = "grey", limits=c(-1,1))
      
      
      
      #Graphs the age linear model betas
      thick_fig <- ggseg(.data=data.frame(area = row.names(thicknesses), Beta = (thicknesses$Age_beta)), mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3, show.legend =F) +  
        labs(title="Thicknesses") + 
        scale1 + 
        theme
      
      
      vol_fig <- ggseg(.data=data.frame(area = row.names(volumes), Beta = (volumes$Age_beta)), mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3, show.legend =F) +  
        labs(title="Volumes") + 
        scale1 + 
        theme
      
      
      aseg_fig <- ggseg(.data=data.frame(area = row.names(subcort), Beta = (subcort$Age_beta)), atlas="aseg", mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3) +  
        labs(title="") + 
        scale1 + 
        theme 
      
      
      age_lm_plots <- plot_grid(thick_fig, vol_fig, ncol = 1, nrow = 2, align = "H")
      age_lm_plots <- plot_grid(age_lm_plots, aseg_fig , ncol = 1, nrow = 2, align = "H")
      #age_lm_plots
      
      
      
      ########### Graphs the slope age linear model ########
      thick_fig <- ggseg(.data=data.frame(area = row.names(thicknesses), Beta = (thicknesses$slope_beta)), mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3, show.legend =F) +  
        labs(title="Thicknesses") + 
        scale2 + 
        theme
      
      
      vol_fig <- ggseg(.data=data.frame(area = row.names(volumes), Beta = (volumes$slope_beta)), mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3, show.legend =F) +  
        labs(title="Volumes") + 
        scale2 + 
        theme
      
      
      aseg_fig <- ggseg(.data=data.frame(area = row.names(subcort), Beta = (subcort$slope_beta)), atlas="aseg", mapping=aes(fill=Beta), hemisphere = "left", colour="black", size=.3) +  
        labs(title="") + 
        scale2 + 
        theme
      
      
      slope_lm_plots <- plot_grid(thick_fig, vol_fig , ncol = 1, nrow = 2, align = "H")
      slope_lm_plots <- plot_grid(slope_lm_plots, aseg_fig , ncol = 1, nrow = 2, align = "H")
      #slope_lm_plots
      
      
      
      ###### Combine Age and Slope beta weight graphs #########
      full_lm_plot <- plot_grid(age_lm_plots, slope_lm_plots , labels = c("Age", "Slope"),label_size = 16,  ncol = 2, nrow = 1, align = "H")
      
      return(full_lm_plot)
      

  }


  output$region_plot <- renderPlot({
    
   
  #do the calculation once to set the y axis - then repeat with the specific choices made
  plotFrame <- fit_data(normals,input$ROI_name, 0.7)
  #Set y-axis (doing this early and then rerunning for sex options so y axis doesn't change)
  y_max <- (plotFrame[order(plotFrame$fit + 3*plotFrame$sd, decreasing = T),][1,]$fit + 3*plotFrame[order(plotFrame$fit + 3*plotFrame$sd, decreasing = T),][1,]$sd) #normals max + 2.5SD (at the max)
  y_min <- (plotFrame[order(plotFrame$fit - 3*plotFrame$sd),][1,]$fit - 3*plotFrame[order(plotFrame$fit - 3*plotFrame$sd),][1,]$sd) #lowest normals data - 2.5 SD (at the min) 
  region_customY <- scale_y_continuous(limits=c(y_min,y_max))
  
  #set x-axis 
  x_min <- n_min - 1
  x_max <- n_max
  region_customX <- scale_x_continuous( breaks=(seq(from = (10*floor(x_min/10)), to = 10*ceiling(x_max/10), by = 10)), limits=c((10*ceiling((x_min)/10)), 10*ceiling(x_max/10)))
  
  
  
  #select out amyloid positives unless selected
  if(!input$pcad){normals <- normals[normals$AD_status=="Amyloid-",]}
  
  #choose sex then repeat calculation
  if(input$sex==2){normals <- normals[normals$Sex=="M",]}
  if(input$sex==3){normals <- normals[normals$Sex=="F",]}
  
  
  plotFrame <- fit_data(normals, input$ROI_name, input$span)
  
  #### Graph Making
  
  #ggplot2 options
  options <- theme(axis.text.x=element_text(size=18),axis.text.y=element_text(size=18),
                   axis.title.x=element_text(size=18,face="bold"),
                   axis.title.y=element_text(size=18,angle=90,face="bold"),
                   legend.text=element_text(size=18),
                   legend.title=element_blank(),legend.position="right",
                   plot.title=element_text(size=18,face="bold",hjust = 0.5),legend.title.align=0.5,
                   plot.subtitle=element_text(size=16))
  
  #Make Plot elements from normals data
  region_plot <- ggplot(plotFrame,aes(x=Age,y=fit))
  region_smoothLine <- geom_line(aes(x=Age,y=fit,colour="Normals"),size=1.25)
  region_smoothRibbon2 <- geom_ribbon(aes(x=Age,ymax=fit+2*sd,ymin=fit-2*sd, fill="2 Std Dev"),alpha=0.1)
  region_smoothRibbon <- geom_ribbon(aes(x=Age,ymax=fit+sd,ymin=fit-sd, fill="1 Std Dev"),alpha=0.5)
  
  #Make Aesthetic Plot elements
  region_xlabel <- xlab("Age") #x label, doesn't change
  if (grepl("thickness", input$ROI_name, ignore.case=T)) {
    region_ylabel <- ylab(expression(bold(paste('Thickness (mm)'))))
    is_volume <- FALSE
  } else {
    region_ylabel <- ylab(expression(bold(paste('Normalized Volume  ',(mm^{3})))))
    is_volume <- TRUE
  }
  
  #set title
  region_title <- ggtitle(input$ROI_name, subtitle = NULL)
  
  
  
  
  
  #set legend labels - do not mess with, reorders labels without clear cause  
  legend  <- scale_colour_manual(name="", labels=c("Average"),  
                                 values = c("1 Std Dev" = "#F8766D", "Normals"="red3", "2 Std Dev"="lightblue"))  
  
  
  #add dotplot of the individual subjects on top of the fit line, if adding in again, must also add + originals to next line
  if(input$pcad){
  originals <- geom_point(data=normals, aes(x=normals$Age, y=normals[,input$ROI_name], shape=factor(AD_status) )) #adds scatter plot of original oasis data overtop the fit line    
  }else{
  originals <- geom_point(data=normals, aes(x=normals$Age, y=normals[,input$ROI_name] )) #adds scatter plot of original oasis data overtop the fit line    
  }

  
  
  Fig <- region_plot + theme_bw() + options  + region_smoothRibbon2 + region_smoothRibbon  + region_smoothLine + region_xlabel + region_ylabel + region_title
  
  #if adding patient data
  if(!is.na(input$region_val) & !is.na(input$Age) & (!is.na(input$ICV) | is_volume==FALSE | input$ROI_name %in% c("IntraCranialVol", "WM Hypointensities Volume", "Non WM Hypointensities Volume"))){
    #Set up if patient is within the age range covered by super normal cohort
    if( (input$Age >= min(normals$Age, na.rm = TRUE)) & (input$Age <= max(normals$Age, na.rm = TRUE)) ){
      ages_within_normals <- TRUE  
      }else{  ages_within_normals <- FALSE  }
    
    #Correct for head volume size
    if(is_volume & !(input$ROI_name %in% c("IntraCranialVol", "WM Hypointensities Volume", "Non WM Hypointensities Volume"))){
      region_val_corrected <- data.frame( input$region_val - as.numeric(ICV_correction_coeff[input$ROI_name])*(input$ICV -     mean(normals$IntraCranialVol) )) #normalizes the patient data based on ICV
    }else{region_val_corrected <- as.numeric(input$region_val) }
    
    
    #Calculate z scores and associates percentiles for each of patient's MR data points
    region_z_score = matrix()
    region_percentile = matrix()
    
    if (ages_within_normals == TRUE){
      smoothFit <- loess( as.matrix(normals[,input$ROI_name]) ~ normals$Age, degree=1, span=input$span) #locally fits a polynomial surface
      stand_dev2 <- matrix()
      for (i in 1:length(n_min:n_max)) {
        stand_dev2[i] <- sd(as.matrix(normals[normals$Age > seq(n_min,n_max, by=1)[i]-1 & normals$Age < seq(n_min,n_max, by=1)[i]+1,][,input$ROI_name]))
      }
      sd_fit <- loess(stand_dev2 ~ c(n_min:n_max), degree=1, span=input$span)
      region_z_score = ((region_val_corrected - predict(smoothFit, newdata=input$Age)) / #instead of plot frame could do , more exact
                          predict(sd_fit, newdata=input$Age)) #Calculated z score of patient's data #instead of plotFrame could do
      
      region_percentile <- round( pnorm(as.numeric(region_z_score))*100, digits = 0 ) #Converts z score into a percentile
      
      if (as.numeric(region_percentile)<1) { region_percentile="1" } #defines percentile if below limit
      
      if (as.numeric(region_percentile)>99) { region_percentile="99" } #defines percentile if above limit
      
      if ((as.numeric(region_percentile)>=1) && (as.numeric(region_percentile)<=99)){
        region_percentile = paste(", ", toOrdinal(region_percentile)," Percentile", sep="") #add a comma to the version being used in the display
      }
      
    }else {
      region_percentile = ""  #leaves percentile blank if patient is outside age range of normal group
    }
    
    #make ggplot element
    region_scatterNorm <- geom_point(aes(x=input$Age,y=as.numeric(region_val_corrected),group="Patient", colour="Patient"),size=4.0) #graphs patient's datapoints
    
    #Add text on patient's data points and calculated percentiles
    #Set up the label
    
    display_label=paste(signif(region_val_corrected, digits=4), t(region_percentile), sep="")
    
    #Use ggrepel to display the label so it doesn't get cut off
    region_volume_text <- geom_text_repel(data=data.frame(input$Age, as.numeric(region_val_corrected)), mapping=aes( x=input$Age, y=as.numeric(region_val_corrected), label=display_label), fontface="bold", size=6, point.padding=unit(.5, 'lines'), box.padding = unit(0.5, 'lines'), force=5 )
    
    #Set y max
    
    if (y_max < region_val_corrected + 0.5*mean(plotFrame$sd, na.rm = TRUE)) {
      y_max <- (region_val_corrected + 0.5*mean(plotFrame$sd, na.rm = TRUE)) #use patient's y max + 0.5 SD as graph max
    }
    
    #Set y min
    if (y_min > region_val_corrected - 0.5*mean(plotFrame$sd, na.rm = TRUE)) {
      y_min <- (region_val_corrected - 0.5*mean(plotFrame$sd, na.rm = TRUE)) #use patient's y max + 0.5 SD as graph max
    }
    
    region_customY <- scale_y_continuous(limits=c(y_min,y_max))
    
       #set x-axis values
       if (input$Age >= x_max) {
         # if the max patient age is over the normals max age, use the patient age as the x axis max
         x_max <- max(input$Age, na.rm = TRUE)
       }
       if (input$Age <= n_min){
         # if the min patient age is below the normals min age, then use the patient age as the x axis min
         x_min <- min(input$Age, na.rm = TRUE)
       }
     
       region_customX <- scale_x_continuous(limits=c(5*floor(x_min/5), 5*ceiling(x_max/5)), breaks=(seq(from = (10*floor(x_min/10)), to = 10*ceiling(x_max/10), by = 10)))
     
       #set legend labels - do not mess with, reorders labels without clear cause
       legend  <- scale_colour_manual(name="", labels=c("Average", "Patient"),
                                      values = c("1 Std Dev" = "#F8766D", "Normals"="red3", "Patient"="#673dbd", "2 Std Dev"="lightblue"))
     
       Fig <- Fig + region_scatterNorm + region_volume_text
    
  } #end of adding patient data
  
  
  #Combine the different elements of the plot
  Fig <- Fig + region_customY + region_customX + legend
  
  if (input$individual_points) {  Fig <- Fig + originals  } 
  
  print(Fig)    
  }, width = 1200, height = 600)

  
  output$table <- renderTable({
    #select out amyloid positives unless selected
    if(!input$pcad){normals <- normals[normals$AD_status=="Amyloid-",]}
    #select correct sex
    if(input$sex==2){normals <- normals[normals$Sex=="M",]}
    if(input$sex==3){normals <- normals[normals$Sex=="F",]}
    #make table
    table <- region_map_data(normals)
    table
    })
  
  output$ggseg_plot <- renderPlot({ 
    #select out amyloid positives unless selected
    if(!input$pcad){normals <- normals[normals$AD_status=="Amyloid-",]}
    #select correct sex
    if(input$sex==2){normals <- normals[normals$Sex=="M",]}
    if(input$sex==3){normals <- normals[normals$Sex=="F",]}
    #make graph
    plot <- ggseg_graph(region_map_data(normals))
    plot
  }, width = 900, height = 800)
})

shinyApp(ui=ui, server=server,  options = list(height = 900, width=1600))

  
```
